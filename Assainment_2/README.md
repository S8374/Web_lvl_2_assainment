#PostgreSQL প্রশ্নোত্তর
##৫টি প্রশ্নের উত্তর
###১. PostgreSQL কি?
PostgreSQL একটি শক্তিশালী, ওপেন সোর্স অবজেক্ট-রিলেশনাল ডাটাবেস ম্যানেজমেন্ট সিস্টেম (ORDBMS)। এটি ৩০ বছরেরও বেশি অ্যাক্টিভ ডেভেলপমেন্টের মাধ্যমে উচ্চ স্তরের ডাটা ইন্টিগ্রিটি, সঠিকতা, কনকারেন্সি, রিলায়াবিলিটি এবং এক্সটেনসিবিলিটি অর্জন করেছে। PostgreSQL স্ট্যান্ডার্ড SQL সমর্থন করে এবং JSON ডাটা querying, জিওগ্রাফিক ডাটা স্টোর, এবং আরও অনেক উন্নত ফিচার প্রদান করে।

###২. PostgreSQL-এ ডাটাবেস স্কিমার উদ্দেশ্য কি?
PostgreSQL-এ ডাটাবেস স্কিমা হল লজিক্যাল কন্টেইনার যেটি ডাটাবেস অবজেক্ট যেমন টেবিল, ভিউ, ইনডেক্স, সিকোয়েন্স, ডাটা টাইপ, ফাংশন ইত্যাদি সংগঠিত করে।** স্কিমার প্রধান উদ্দেশ্য হল:**

-ডাটাবেস অবজেক্টগুলিকে লজিক্যাল গ্রুপে সংগঠিত করা ।

-একাধিক ইউজারকে একটি ডাটাবেস ব্যবহার করতে দেয়া তাদের নিজস্ব স্কিমায়

তৃতীয় পক্ষের অ্যাপ্লিকেশনের অবজেক্টগুলিকে আলাদা রাখা
নামের কনফ্লিক্ট এড়ানো ।

###৩. PostgreSQL-এ প্রাইমারি কী এবং ফরেন কী এর ধারণা ব্যাখ্যা করুন
**প্রাইমারি কী (Primary Key):**

-একটি টেবিলের প্রতিটি রেকর্ডকে ইউনিকভাবে আইডেন্টিফাই করে

NULL হতে পারে না ।

-একটি টেবিলে শুধুমাত্র একটি প্রাইমারি কী থাকতে পারে

স্বয়ংক্রিয়ভাবে একটি ইউনিক ইনডেক্স তৈরি করে ।

**ফরেন কী (Foreign Key):**

-একটি টেবিলের কলাম বা কলামের গ্রুপ যা অন্য টেবিলের প্রাইমারি কীকে রেফারেন্স করে

রেফারেন্সিয়াল ইন্টিগ্রিটি বজায় রাখে ।

-পারেন্ট টেবিলে যে মান নেই তা চাইল্ড টেবিলে ঢুকতে দেয় না ।

###৪. VARCHAR এবং CHAR ডাটা টাইপের মধ্যে পার্থক্য কি?
**CHAR:**

-ফিক্সড-লেংথ স্ট্রিং ডাটা টাইপ ।

-ডিফাইন করা লেংথ পর্যন্ত প্যাড করা হয় স্পেস দিয়ে -

```উদাহরণ:
 CHAR(10) সবসময় ১০ ক্যারেক্টার নেবে, যদি স্ট্রিং ছোট হয় তাহলে স্পেস দিয়ে প্যাড করবে  ।

স্টোরেজ: ডিক্লেয়ার করা লেংথ অনুযায়ী ফিক্সড সাইজ  ।
```

**VARCHAR:**

-ভ্যারিয়েবল-লেংথ স্ট্রিং ডাটা টাইপ

-শুধুমাত্র ইনপুট করা ডাটা স্টোর করে, অতিরিক্ত স্পেস প্যাড করে না ।

```উদাহরণ:
 VARCHAR(10) ০ থেকে ১০ ক্যারেক্টার পর্যন্ত নিতে পারে

স্টোরেজ: শুধুমাত্র ইনপুট করা ডাটার সাইজ অনুযায়ী
```

###৫. SELECT স্টেটমেন্টে WHERE ক্লজের উদ্দেশ্য কি?
WHERE ক্লজের উদ্দেশ্য হল SELECT স্টেটমেন্ট দ্বারা রিটার্ন করা রো/রেকর্ডগুলো ফিল্টার করা। এটি শর্ত নির্দিষ্ট করে যে কোন রো গুলো রিটার্ন করা হবে। WHERE ক্লজে আপনি লজিক্যাল এক্সপ্রেশন (যেমন =, <>, >, <, LIKE, IN, BETWEEN ইত্যাদি) ব্যবহার করে ডাটা ফিল্টার করতে পারেন।

\*\*\*উদাহরণ:

```sql
SELECT * FROM employees WHERE salary > 50000;
এই কুয়েরি শুধুমাত্র সেই সব কর্মচারীদের রেকর্ড রিটার্ন করবে যাদের বেতন ৫০,০০০ এর বেশি।
```

#বাকি প্রশ্নগুলোর উত্তর :

###৬. LIMIT এবং OFFSET ক্লজ কি জন্য ব্যবহৃত হয়?
LIMIT: কুয়েরি রেজাল্টে রিটার্ন করা রো সংখ্যা সীমিত করে।

```sql
SELECT * FROM products LIMIT 10; -- প্রথম ১০টি প্রোডাক্ট রিটার্ন করে
OFFSET: কুয়েরি রেজাল্টে শুরু করার আগে কতগুলো রো স্কিপ করতে হবে তা নির্দেশ করে।
```

```sql
SELECT * FROM products LIMIT 10 OFFSET 20; -- প্রথম ২০টি রো স্কিপ করে পরের ১০টি রো রিটার্ন করে
```

এগুলি সাধারণত পেজিনেশনের জন্য ব্যবহৃত হয়।

###৭. UPDATE স্টেটমেন্ট ব্যবহার করে কিভাবে ডাটা মডিফাই করবেন?
UPDATE স্টেটমেন্ট বিদ্যমান টেবিলের রো আপডেট করতে ব্যবহৃত হয়। বেসিক সিনট্যাক্স:

```sql
UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;
```

**উদাহরণ:**

```sql
UPDATE employees
SET salary = 60000, department = 'IT'
WHERE employee_id = 101;
```

সতর্কতা: WHERE ক্লজ ছাড়া UPDATE চালালে টেবিলের সব রো আপডেট হয়ে যাবে!

###৮. JOIN অপারেশনের তাৎপর্য কি এবং PostgreSQL-এ এটি কিভাবে কাজ করে?
JOIN অপারেশন একাধিক টেবিল থেকে ডাটা একত্রিত করে। PostgreSQL নিম্নলিখিত JOIN টাইপ সমর্থন করে:

-**INNER JOIN:** শুধুমাত্র ম্যাচিং রো রিটার্ন করে

-**LEFT JOIN:** বাম টেবিলের সব রো এবং ডান টেবিলের ম্যাচিং রো রিটার্ন করে

-**RIGHT JOIN:** ডান টেবিলের সব রো এবং বাম টেবিলের ম্যাচিং রো রিটার্ন করে

-**FULL JOIN:** উভয় টেবিলের সব রো রিটার্ন করে যখন ম্যাচ হয়

**উদাহরণ:**

```sql
SELECT employees.name, departments.department_name
FROM employees
INNER JOIN departments ON employees.department_id = departments.id;
```

###৯. GROUP BY ক্লজ এবং এগ্রিগেশন অপারেশনে এর ভূমিকা ব্যাখ্যা করুন
GROUP BY ক্লজ একই মান বিশিষ্ট রো গুলোকে গ্রুপ করে। এটি সাধারণত COUNT(), SUM(), AVG(), MAX(), MIN() এর মত এগ্রিগেট ফাংশনের সাথে ব্যবহার করা হয়।

-**উদাহরণ:**

```sql
SELECT department, COUNT(*) as employee_count, AVG(salary) as avg_salary
FROM employees
GROUP BY department;
```

এই কুয়েরি প্রতিটি ডিপার্টমেন্টের জন্য কর্মচারী সংখ্যা এবং গড় বেতন গণনা করে।

###১০. PostgreSQL-এ COUNT(), SUM(), এবং AVG() এর মত এগ্রিগেট ফাংশন কিভাবে ক্যালকুলেট করবেন?
COUNT(): রো সংখ্যা গণনা করে

```sql
SELECT COUNT(*) FROM employees; -- সব রো কাউন্ট করে
SELECT COUNT(DISTINCT department) FROM employees; -- ইউনিক ডিপার্টমেন্ট কাউন্ট করে
SUM(): সংখ্যাসূচক কলামের মানের যোগফল প্রদান করে
```

```sql
SELECT SUM(salary) FROM employees; -- সব কর্মচারীর বেতনের যোগফল
SELECT department, SUM(salary) FROM employees GROUP BY department; -- ডিপার্টমেন্ট অনুযায়ী বেতনের যোগফল
AVG(): সংখ্যাসূচক কলামের গড় মান প্রদান করে
```

```sql
SELECT AVG(salary) FROM employees; -- সব কর্মচারীর গড় বেতন
SELECT department, AVG(salary) FROM employees GROUP BY department; -- ডিপার্টমেন্ট অনুযায়ী গড় বেতন
```
